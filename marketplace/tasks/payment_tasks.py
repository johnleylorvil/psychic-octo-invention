# marketplace/tasks/payment_tasks.py

import logging
from celery import shared_task
from celery.exceptions import Retry
from django.db import transaction, IntegrityError
from django.utils import timezone
from django.core.mail import mail_admins
from django.conf import settings
from datetime import timedelta
from ..models import Transaction, Order, Cart
from ..services.moncash_service import (
    MonCashService, 
    MonCashError, 
    ServiceUnavailableError,
    moncash_service
)

logger = logging.getLogger(__name__)


@shared_task(
    bind=True,
    max_retries=3,                    # üö® LIMITE STRICTE - max 3 tentatives
    default_retry_delay=60,           # üö® 60 secondes entre retries
    retry_backoff=True,               # üö® Exponential backoff (60s, 120s, 240s)
    retry_backoff_max=600,            # üö® Max 10 minutes de d√©lai
    retry_jitter=True,                # üö® Randomisation pour √©viter thundering herd
    time_limit=300,                   # üö® Limite 5 minutes par t√¢che
    soft_time_limit=240               # üö® Warning √† 4 minutes
)
def process_payment_webhook(self, webhook_data):
    """
    Traiter webhook MonCash avec protection contre boucles infinies
    
    Args:
        webhook_data: Dict avec donn√©es du webhook MonCash
        
    Returns:
        Dict avec status et d√©tails du traitement
        
    ‚ö†Ô∏è S√âCURIT√â CRITIQUE :
    - Max 3 retries avec exponential backoff
    - Idempotence stricte (pas de double traitement)
    - SELECT FOR UPDATE pour √©viter race conditions
    - Gestion d'erreurs diff√©renci√©e (retry vs fail d√©finitif)
    """
    task_id = self.request.id
    transaction_id = webhook_data.get('transactionId', 'unknown')
    order_id = webhook_data.get('orderId', 'unknown')
    
    logger.info(
        f"üîÑ Processing payment webhook - Task: {task_id}, "
        f"Transaction: {transaction_id}, Order: {order_id}, "
        f"Retry: {self.request.retries}/{self.max_retries}"
    )
    
    try:
        # üö® V√âRIFICATION IDEMPOTENCE CRITIQUE
        # Emp√™che le double traitement m√™me en cas de retry
        with transaction.atomic():
            existing_transaction = Transaction.objects.filter(
                moncash_order_id=transaction_id
            ).first()
            
            if existing_transaction and existing_transaction.status == 'completed':
                logger.info(
                    f"‚úÖ Transaction {transaction_id} already processed - SKIPPING"
                )
                return {
                    'status': 'already_processed',
                    'transaction_id': transaction_id,
                    'existing_status': existing_transaction.status,
                    'skip_reason': 'idempotence_check'
                }
        
        # üéØ VALIDATION DONN√âES WEBHOOK
        try:
            # Utiliser le service MonCash pour parser et valider
            parsed_data = MonCashService.parse_webhook_data(
                webhook_data if isinstance(webhook_data, str) else str(webhook_data)
            )
            
            if not moncash_service.validate_webhook_signature(
                str(webhook_data), 
                ""  # MonCash ne fournit pas de signature selon la doc
            ):
                logger.error(f"‚ùå Invalid webhook signature for transaction {transaction_id}")
                # üö® PAS DE RETRY pour erreurs de validation
                return {
                    'status': 'failed',
                    'error': 'invalid_webhook_signature',
                    'transaction_id': transaction_id
                }
                
        except MonCashError as exc:
            logger.error(f"‚ùå Webhook data validation failed: {exc}")
            # üö® PAS DE RETRY pour erreurs de donn√©es
            return {
                'status': 'failed',
                'error': 'invalid_webhook_data',
                'details': str(exc)
            }
        
        # üéØ TRAITEMENT BUSINESS LOGIC ATOMIQUE
        result = _process_webhook_business_logic(parsed_data, task_id)
        
        logger.info(
            f"‚úÖ Webhook processed successfully - Transaction: {transaction_id}, "
            f"Result: {result['status']}"
        )
        
        return result
        
    except (ConnectionError, TimeoutError, ServiceUnavailableError) as exc:
        # üö® RETRY SEULEMENT pour erreurs r√©seau/service temporaires
        logger.warning(
            f"‚ö†Ô∏è Network/service error processing webhook - Transaction: {transaction_id}, "
            f"Retry {self.request.retries}/{self.max_retries}: {exc}"
        )
        
        # V√©rifier si on a atteint le max de retries
        if self.request.retries >= self.max_retries:
            logger.critical(
                f"üí• Payment webhook FAILED after {self.max_retries} retries - "
                f"Transaction: {transaction_id}, Error: {exc}"
            )
            
            # Alerter les admins pour intervention manuelle
            _send_admin_alert_webhook_failure(webhook_data, exc, self.max_retries)
            
            return {
                'status': 'failed_permanently',
                'error': 'max_retries_exceeded',
                'transaction_id': transaction_id,
                'final_error': str(exc)
            }
        
        # üîÑ RETRY avec exponential backoff
        raise self.retry(exc=exc)
        
    except (ValueError, TypeError, KeyError, IntegrityError) as exc:
        # üö® PAS DE RETRY pour erreurs de donn√©es/logique
        logger.error(
            f"‚ùå Data/logic error processing webhook - NO RETRY - "
            f"Transaction: {transaction_id}: {exc}"
        )
        
        return {
            'status': 'failed',
            'error': 'data_logic_error',
            'transaction_id': transaction_id,
            'details': str(exc)
        }
        
    except Exception as exc:
        # üö® Erreurs inattendues = retry limit√© puis fail
        logger.error(
            f"‚ùå Unexpected error processing webhook - Transaction: {transaction_id}: {exc}"
        )
        
        if self.request.retries >= self.max_retries:
            logger.critical(
                f"üí• Payment webhook FAILED with unexpected error after {self.max_retries} retries - "
                f"Transaction: {transaction_id}"
            )
            
            _send_admin_alert_webhook_failure(webhook_data, exc, self.max_retries)
            
            return {
                'status': 'failed_permanently',
                'error': 'unexpected_error',
                'transaction_id': transaction_id,
                'details': str(exc)
            }
        
        raise self.retry(exc=exc)


def _process_webhook_business_logic(parsed_data, task_id):
    """
    Logique m√©tier pour traiter un webhook avec protection atomique
    
    Args:
        parsed_data: Donn√©es webhook pars√©es et valid√©es
        task_id: ID de la t√¢che Celery pour logging
        
    Returns:
        Dict avec r√©sultat du traitement
    """
    transaction_id = parsed_data['transaction_id']
    order_id = parsed_data['order_id']
    
    # üö® VERROU ATOMIQUE pour √©viter race conditions
    with transaction.atomic():
        try:
            # SELECT FOR UPDATE pour lock exclusif
            transaction_obj = Transaction.objects.select_for_update().get(
                moncash_order_id=transaction_id
            )
            
        except Transaction.DoesNotExist:
            logger.error(f"‚ùå Transaction {transaction_id} not found in database")
            return {
                'status': 'transaction_not_found',
                'transaction_id': transaction_id,
                'order_id': order_id
            }
        
        # üö® V√âRIFICATION √âTAT avant traitement
        if transaction_obj.status != 'pending':
            logger.info(
                f"‚ÑπÔ∏è Transaction {transaction_id} already in state {transaction_obj.status} - skipping"
            )
            return {
                'status': 'already_processed',
                'transaction_id': transaction_id,
                'current_status': transaction_obj.status,
                'order_number': transaction_obj.order.order_number if transaction_obj.order else None
            }
        
        # üéØ MISE √Ä JOUR TRANSACTION
        if parsed_data['status'] == 'successful':
            transaction_obj.status = 'completed'
            transaction_obj.verified_at = timezone.now()
            transaction_obj.reference_number = parsed_data.get('reference', '')
            
            # Sauvegarder gateway response compl√®te pour audit
            transaction_obj.gateway_response = parsed_data['raw_data']
            transaction_obj.webhook_received_at = timezone.now()
            transaction_obj.save()
            
            # üéØ MISE √Ä JOUR ORDER
            if transaction_obj.order:
                order = transaction_obj.order
                order.payment_status = 'paid'
                order.status = 'confirmed'
                order.admin_notes = f"Paiement confirm√© par webhook le {timezone.now()}"
                order.save()
                
                logger.info(
                    f"‚úÖ Order {order.order_number} marked as paid - "
                    f"Amount: {transaction_obj.amount} {transaction_obj.currency}"
                )
                
                return {
                    'status': 'success',
                    'transaction_id': transaction_id,
                    'order_number': order.order_number,
                    'amount': str(transaction_obj.amount),
                    'currency': transaction_obj.currency,
                    'payment_confirmed': True
                }
            else:
                logger.warning(f"‚ö†Ô∏è Transaction {transaction_id} has no associated order")
                return {
                    'status': 'success_no_order',
                    'transaction_id': transaction_id,
                    'amount': str(transaction_obj.amount)
                }
        else:
            # Paiement √©chou√©
            transaction_obj.status = 'failed'
            transaction_obj.failure_reason = parsed_data.get('message', 'Payment failed')
            transaction_obj.gateway_response = parsed_data['raw_data']
            transaction_obj.webhook_received_at = timezone.now()
            transaction_obj.save()
            
            # Marquer order comme √©chec paiement
            if transaction_obj.order:
                order = transaction_obj.order
                order.payment_status = 'failed'
                order.admin_notes = f"Paiement √©chou√© le {timezone.now()}: {parsed_data.get('message', 'Unknown error')}"
                order.save()
                
                logger.warning(
                    f"‚ö†Ô∏è Payment failed for order {order.order_number} - "
                    f"Reason: {parsed_data.get('message', 'Unknown')}"
                )
            
            return {
                'status': 'payment_failed',
                'transaction_id': transaction_id,
                'order_number': transaction_obj.order.order_number if transaction_obj.order else None,
                'failure_reason': parsed_data.get('message', 'Payment failed')
            }


@shared_task(
    bind=True,
    max_retries=1,                    # üö® MAX 1 retry pour nettoyage
    default_retry_delay=300,          # üö® 5 minutes entre retries
    time_limit=600,                   # üö® Max 10 minutes
)
def cleanup_expired_carts(self):
    """
    Nettoyage paniers expir√©s - LIMITE STRICTE pour √©viter surcharge
    
    ‚ö†Ô∏è S√âCURIT√â :
    - Max 1000 paniers par ex√©cution
    - Soft delete (is_active=False) au lieu de suppression
    - Limite de temps stricte
    """
    try:
        cutoff_time = timezone.now()
        
        # Trouver paniers expir√©s
        expired_carts = Cart.objects.filter(
            expires_at__lt=cutoff_time,
            is_active=True
        )
        
        count = expired_carts.count()
        
        if count == 0:
            logger.info("üßπ No expired carts to cleanup")
            return {'status': 'success', 'cleaned_count': 0}
        
        # üö® PROTECTION contre suppression massive
        if count > 1000:
            logger.warning(
                f"‚ö†Ô∏è Too many expired carts ({count}) - limiting to 1000 for safety"
            )
            expired_carts = expired_carts[:1000]
            count = 1000
        
        # Soft delete pour pr√©server historique
        updated = expired_carts.update(
            is_active=False,
            updated_at=timezone.now()
        )
        
        logger.info(f"üßπ Cleaned up {updated} expired carts")
        
        return {
            'status': 'success',
            'cleaned_count': updated,
            'cutoff_time': cutoff_time.isoformat()
        }
        
    except Exception as exc:
        logger.error(f"‚ùå Cart cleanup failed: {exc}")
        
        # üö® PAS DE RETRY automatique pour √©viter surcharge
        # Les admins recevront une alerte via monitoring
        return {
            'status': 'failed',
            'error': str(exc),
            'retry_count': self.request.retries
        }


@shared_task(
    bind=True,
    max_retries=2,                    # üö® Max 2 retries pour monitoring
    default_retry_delay=120,          # üö® 2 minutes entre retries
    time_limit=180,                   # üö® Max 3 minutes
)
def monitor_stuck_payments(self):
    """
    Monitoring des paiements bloqu√©s - SANS RETRY automatique sur business logic
    
    D√©tecte :
    - Transactions pending depuis plus de 1h
    - Orders avec payment_status incoh√©rent
    - Webhooks manqu√©s
    """
    try:
        cutoff_time = timezone.now() - timedelta(hours=1)
        
        # Transactions bloqu√©es en pending
        stuck_transactions = Transaction.objects.filter(
            status='pending',
            created_at__lt=cutoff_time
        ).select_related('order')
        
        stuck_count = stuck_transactions.count()
        
        if stuck_count > 0:
            logger.warning(f"‚ö†Ô∏è Found {stuck_count} stuck payment transactions")
            
            # Pr√©parer d√©tails pour alerte admin
            stuck_details = []
            for trans in stuck_transactions[:10]:  # Limite √† 10 pour alerte
                stuck_details.append({
                    'transaction_id': trans.transaction_id,
                    'order_number': trans.order.order_number if trans.order else None,
                    'amount': str(trans.amount),
                    'created_at': trans.created_at.isoformat(),
                    'age_hours': (timezone.now() - trans.created_at).total_seconds() / 3600
                })
            
            # üö® ALERTE ADMIN sans retry automatique
            _send_admin_alert_stuck_payments(stuck_details, stuck_count)
            
            return {
                'status': 'alert_sent',
                'stuck_count': stuck_count,
                'details_sent': len(stuck_details)
            }
        else:
            logger.info("‚úÖ No stuck payments found")
            return {
                'status': 'success',
                'stuck_count': 0,
                'message': 'No stuck payments'
            }
            
    except Exception as exc:
        logger.error(f"‚ùå Payment monitoring failed: {exc}")
        
        if self.request.retries < self.max_retries:
            logger.info(f"üîÑ Retrying payment monitoring - Attempt {self.request.retries + 1}")
            raise self.retry(exc=exc)
        
        # Apr√®s max retries, alerter les admins
        _send_admin_alert_monitoring_failure(exc)
        
        return {
            'status': 'failed',
            'error': str(exc),
            'max_retries_reached': True
        }


def _send_admin_alert_webhook_failure(webhook_data, error, max_retries):
    """Envoyer alerte admin pour √©chec webhook critique"""
    try:
        subject = "üö® CRITICAL: MonCash Webhook Processing Failed"
        
        message = f"""
        ALERTE CRITIQUE : √âchec traitement webhook MonCash apr√®s {max_retries} tentatives
        
        D√©tails webhook :
        - Transaction ID: {webhook_data.get('transactionId', 'Unknown')}
        - Order ID: {webhook_data.get('orderId', 'Unknown')}
        - Montant: {webhook_data.get('amount', 'Unknown')}
        - Message: {webhook_data.get('message', 'Unknown')}
        
        Erreur finale : {error}
        
        ACTION REQUISE :
        1. V√©rifier statut paiement dans MonCash Business Portal
        2. R√©concilier manuellement si n√©cessaire
        3. Contacter support MonCash si probl√®me persiste
        
        Donn√©es compl√®tes webhook :
        {webhook_data}
        """
        
        mail_admins(subject, message, fail_silently=False)
        logger.critical(f"Admin alert sent for webhook failure: {webhook_data.get('transactionId')}")
        
    except Exception as exc:
        logger.error(f"Failed to send admin alert for webhook failure: {exc}")


def _send_admin_alert_stuck_payments(stuck_details, total_count):
    """Envoyer alerte admin pour paiements bloqu√©s"""
    try:
        subject = f"‚ö†Ô∏è WARNING: {total_count} Stuck Payment Transactions Detected"
        
        details_text = "\n".join([
            f"- Transaction {detail['transaction_id']} (Order: {detail['order_number']}) "
            f"Amount: {detail['amount']} HTG - Age: {detail['age_hours']:.1f}h"
            for detail in stuck_details
        ])
        
        message = f"""
        D√©tection de {total_count} transactions de paiement bloqu√©es depuis plus d'1 heure.
        
        D√©tails (10 premiers) :
        {details_text}
        
        Actions recommand√©es :
        1. V√©rifier statut dans MonCash Business Portal
        2. Relancer webhooks manqu√©s si n√©cessaire
        3. Investiguer probl√®mes de connectivit√©
        
        Dashboard admin : {settings.SITE_URL}/admin/marketplace/transaction/
        """
        
        mail_admins(subject, message, fail_silently=False)
        logger.warning(f"Admin alert sent for {total_count} stuck payments")
        
    except Exception as exc:
        logger.error(f"Failed to send stuck payments alert: {exc}")


def _send_admin_alert_monitoring_failure(error):
    """Envoyer alerte admin pour √©chec monitoring"""
    try:
        subject = "üö® ERROR: Payment Monitoring System Failed"
        
        message = f"""
        Le syst√®me de monitoring des paiements a √©chou√©.
        
        Erreur : {error}
        Timestamp : {timezone.now()}
        
        Le monitoring automatique est temporairement indisponible.
        V√©rification manuelle recommand√©e.
        """
        
        mail_admins(subject, message, fail_silently=False)
        
    except Exception as exc:
        logger.error(f"Failed to send monitoring failure alert: {exc}")